/* Base class for driver exploits and provider interface. */

#pragma once

#include <windows.h>
#include <expected>
#include <memory>
#include <print>
#include <string>
#include <string_view>
#include <typeinfo>
#include <filesystem>

#include "ability_flags.h"

namespace kdu::core {

/**
 * @brief Base class for all driver exploit implementations.
 *
 * This class manages the device handle and provides interface query
 * capabilities. Each specific driver exploit should inherit from this class.
 */
class DriverExploit {
   public:
    explicit DriverExploit(HANDLE device_handle,
                           std::wstring service_name = L"") noexcept
        : device_handle_(device_handle),
          service_name_(std::move(service_name)) {}

    virtual ~DriverExploit() {
        if (device_handle_ != INVALID_HANDLE_VALUE &&
            device_handle_ != nullptr) {
            CloseHandle(device_handle_);
        }

        if (!try_unload()) {
            std::println("Warning: Failed to unload driver service: {}",
                         std::filesystem::path(service_name_).string());
        }
    }

    // Non-copyable
    DriverExploit(const DriverExploit&) = delete;
    DriverExploit& operator=(const DriverExploit&) = delete;

    // Movable
    DriverExploit(DriverExploit&& other) noexcept
        : device_handle_(other.device_handle_) {
        other.device_handle_ = INVALID_HANDLE_VALUE;
    }

    DriverExploit& operator=(DriverExploit&& other) noexcept {
        if (this != &other) {
            if (device_handle_ != INVALID_HANDLE_VALUE) {
                CloseHandle(device_handle_);
            }
            device_handle_ = other.device_handle_;
            other.device_handle_ = INVALID_HANDLE_VALUE;
        }
        return *this;
    }

    /**
     * @brief Gets the device handle.
     */
    [[nodiscard]] HANDLE device_handle() const noexcept {
        return device_handle_;
    }

    /**
     * @brief Attempts to unload the driver.
     * Default implementation uses unload_driver with service_name.
     * @return Expected containing success or error message.
     */
    [[nodiscard]] virtual std::expected<void, std::string>
    try_unload() noexcept;

    /**
     * @brief Safely query for a specific interface.
     * @tparam T The interface type to query.
     * @return Pointer to the interface if supported, nullptr otherwise.
     */
    template <typename T>
    [[nodiscard]] T* as() noexcept {
        return dynamic_cast<T*>(this);
    }

    /**
     * @brief Safely query for a specific interface (const version).
     * @tparam T The interface type to query.
     * @return Pointer to the interface if supported, nullptr otherwise.
     */
    template <typename T>
    [[nodiscard]] const T* as() const noexcept {
        return dynamic_cast<const T*>(this);
    }

    // Utilities
    BOOL call_driver(HANDLE hDevice,
                     DWORD dwIoControlCode,
                     LPVOID lpInBuffer,
                     DWORD nInBufferSize,
                     LPVOID lpOutBuffer,
                     DWORD nOutBufferSize) const {
        DWORD dwBytesReturned = 0;
        auto res = DeviceIoControl(hDevice, dwIoControlCode, lpInBuffer,
                                   nInBufferSize, lpOutBuffer, nOutBufferSize,
                                   &dwBytesReturned, nullptr);
        if (!res) {
            std::println("DeviceIoControl failed: {}", GetLastError());
        }
        return res;
    }

   protected:
    HANDLE device_handle_;
    std::wstring service_name_;
};

/**
 * @brief Provider metadata for a driver exploit.
 */
struct DriverMetadata {
    std::string driver_name;     // e.g., "gdrv"
    std::string device_name;     // e.g., "\\\\.\\GIO"
    std::string service_name;    // Service name for SC manager
    std::string description;     // Human-readable description
    std::string cve_id;          // e.g., "CVE-2018-19320"
    const uint8_t* driver_data;  // Pointer to embedded driver binary
    size_t driver_size;          // Size of embedded driver binary
    AbilityFlags capabilities;   // Supported capabilities
};

/**
 * @brief Factory interface for creating driver exploit instances.
 *
 * Each driver provider must implement this interface to enable
 * dynamic discovery and instantiation.
 */
class IDriverProvider {
   public:
    virtual ~IDriverProvider() = default;

    /**
     * @brief Gets metadata about this driver.
     */
    [[nodiscard]] const DriverMetadata& metadata() const noexcept {
        return metadata_;
    }

    /**
     * @brief Checks if the driver can be loaded on the current system.
     * @return Expected containing success or error message.
     */
    [[nodiscard]] virtual std::expected<void, std::string> check_available()
        const noexcept = 0;

    /**
     * @brief Creates an instance of the driver exploit.
     * This handles loading the driver, creating service, etc.
     * @return Expected containing the exploit instance on success, or error
     * message on failure.
     */
    [[nodiscard]] virtual std::expected<std::unique_ptr<DriverExploit>,
                                        std::string>
    create_instance() noexcept = 0;

   protected:
    /**
     * @brief Loads a driver from memory into the system.
     * @param driver_data Pointer to driver binary data
     * @param driver_size Size of driver binary
     * @param service_name Name for the service
     * @param device_name Device name to open (e.g., "\\\\.\\GIO")
     * @return Expected containing device handle on success
     */
    [[nodiscard]] static std::expected<HANDLE, std::string>
    load_driver_from_memory(const uint8_t* driver_data,
                            size_t driver_size,
                            const std::wstring& service_name,
                            const std::wstring& device_name) noexcept;

    /**
     * @brief Unloads a driver and removes its service.
     * @param service_name Name of the service to remove
     * @return Expected containing success or error message
     */
    [[nodiscard]] static std::expected<void, std::string> unload_driver(
        const std::wstring& service_name) noexcept;

    DriverMetadata metadata_;

    friend class DriverExploit;
};

}  // namespace kdu::core
